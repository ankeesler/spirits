// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: spirits/v1/battle.proto

package spiritsv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BattleServiceClient is the client API for BattleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BattleServiceClient interface {
	// CreateBattle creates, but doesn't start, a Battle.
	//
	// After a Battle is created, one might want to AddTeams's and then
	// AddSpirit's.
	CreateBattle(ctx context.Context, in *CreateBattleRequest, opts ...grpc.CallOption) (*CreateBattleResponse, error)
	// WatchBattle streams Battle updates.
	//
	// Everytime a change is made to a Battle, a response will be sent on the
	// stream.
	WatchBattle(ctx context.Context, in *WatchBattleRequest, opts ...grpc.CallOption) (BattleService_WatchBattleClient, error)
	// ListBattles will list a history of known Battle's.
	ListBattles(ctx context.Context, in *ListBattlesRequest, opts ...grpc.CallOption) (*ListBattlesResponse, error)
	// AddBattleTeam creates an empty Team in a Battle.
	//
	// AddBattleTeam can only be called when a Battle has BattleState
	// BATTLE_STATE_PENDING.
	//
	// After a BattleTeam is created, one might want to AddBattleTeamSpirit's.
	AddBattleTeam(ctx context.Context, in *AddBattleTeamRequest, opts ...grpc.CallOption) (*AddBattleTeamResponse, error)
	// AddBattleTeamSpirit adds a Spirit into a Battle via inclusion in a Team.
	//
	// Note that when a Spirit is added to a Battle, no future external updates to
	// the Spirit will be incoporated into the Battle. In order to Battle with the
	// updated Spirit, a new Battle must be created.
	//
	// After Spirit's are added, one might want to StartBattle.
	AddBattleTeamSpirit(ctx context.Context, in *AddBattleTeamSpiritRequest, opts ...grpc.CallOption) (*AddBattleTeamSpiritResponse, error)
	// StartBattle progresses the Battle from BattleStatus BATTLE_STATE_PENDING to
	// BATTLE_STATE_STARTED (and thus can only be called when the BattleStatus is
	// BATTLE_STATE_PENDING).
	//
	// After StartBattle is called, one might want to WatchBattle.
	StartBattle(ctx context.Context, in *StartBattleRequest, opts ...grpc.CallOption) (*StartBattleResponse, error)
	// CancelBattle forcefully halts a Battle.
	//
	// The Battle's BattleState will be set to BATTLE_STATE_CANCELLED.
	CancelBattle(ctx context.Context, in *CancelBattleRequest, opts ...grpc.CallOption) (*CancelBattleResponse, error)
	// CallAction invokes an acting Spirit's SpiritAction.
	//
	// This is only valid when a Spirit is currently acting, and
	// the Spirit's BattleTeamSpiritIntelligence is
	// BATTLE_TEAM_SPIRIT_INTELLIGENCE_HUMAN.
	CallAction(ctx context.Context, in *CallActionRequest, opts ...grpc.CallOption) (*CallActionResponse, error)
}

type battleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBattleServiceClient(cc grpc.ClientConnInterface) BattleServiceClient {
	return &battleServiceClient{cc}
}

func (c *battleServiceClient) CreateBattle(ctx context.Context, in *CreateBattleRequest, opts ...grpc.CallOption) (*CreateBattleResponse, error) {
	out := new(CreateBattleResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/CreateBattle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) WatchBattle(ctx context.Context, in *WatchBattleRequest, opts ...grpc.CallOption) (BattleService_WatchBattleClient, error) {
	stream, err := c.cc.NewStream(ctx, &BattleService_ServiceDesc.Streams[0], "/spirits.v1.BattleService/WatchBattle", opts...)
	if err != nil {
		return nil, err
	}
	x := &battleServiceWatchBattleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BattleService_WatchBattleClient interface {
	Recv() (*WatchBattleResponse, error)
	grpc.ClientStream
}

type battleServiceWatchBattleClient struct {
	grpc.ClientStream
}

func (x *battleServiceWatchBattleClient) Recv() (*WatchBattleResponse, error) {
	m := new(WatchBattleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *battleServiceClient) ListBattles(ctx context.Context, in *ListBattlesRequest, opts ...grpc.CallOption) (*ListBattlesResponse, error) {
	out := new(ListBattlesResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/ListBattles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) AddBattleTeam(ctx context.Context, in *AddBattleTeamRequest, opts ...grpc.CallOption) (*AddBattleTeamResponse, error) {
	out := new(AddBattleTeamResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/AddBattleTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) AddBattleTeamSpirit(ctx context.Context, in *AddBattleTeamSpiritRequest, opts ...grpc.CallOption) (*AddBattleTeamSpiritResponse, error) {
	out := new(AddBattleTeamSpiritResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/AddBattleTeamSpirit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) StartBattle(ctx context.Context, in *StartBattleRequest, opts ...grpc.CallOption) (*StartBattleResponse, error) {
	out := new(StartBattleResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/StartBattle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) CancelBattle(ctx context.Context, in *CancelBattleRequest, opts ...grpc.CallOption) (*CancelBattleResponse, error) {
	out := new(CancelBattleResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/CancelBattle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) CallAction(ctx context.Context, in *CallActionRequest, opts ...grpc.CallOption) (*CallActionResponse, error) {
	out := new(CallActionResponse)
	err := c.cc.Invoke(ctx, "/spirits.v1.BattleService/CallAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BattleServiceServer is the server API for BattleService service.
// All implementations must embed UnimplementedBattleServiceServer
// for forward compatibility
type BattleServiceServer interface {
	// CreateBattle creates, but doesn't start, a Battle.
	//
	// After a Battle is created, one might want to AddTeams's and then
	// AddSpirit's.
	CreateBattle(context.Context, *CreateBattleRequest) (*CreateBattleResponse, error)
	// WatchBattle streams Battle updates.
	//
	// Everytime a change is made to a Battle, a response will be sent on the
	// stream.
	WatchBattle(*WatchBattleRequest, BattleService_WatchBattleServer) error
	// ListBattles will list a history of known Battle's.
	ListBattles(context.Context, *ListBattlesRequest) (*ListBattlesResponse, error)
	// AddBattleTeam creates an empty Team in a Battle.
	//
	// AddBattleTeam can only be called when a Battle has BattleState
	// BATTLE_STATE_PENDING.
	//
	// After a BattleTeam is created, one might want to AddBattleTeamSpirit's.
	AddBattleTeam(context.Context, *AddBattleTeamRequest) (*AddBattleTeamResponse, error)
	// AddBattleTeamSpirit adds a Spirit into a Battle via inclusion in a Team.
	//
	// Note that when a Spirit is added to a Battle, no future external updates to
	// the Spirit will be incoporated into the Battle. In order to Battle with the
	// updated Spirit, a new Battle must be created.
	//
	// After Spirit's are added, one might want to StartBattle.
	AddBattleTeamSpirit(context.Context, *AddBattleTeamSpiritRequest) (*AddBattleTeamSpiritResponse, error)
	// StartBattle progresses the Battle from BattleStatus BATTLE_STATE_PENDING to
	// BATTLE_STATE_STARTED (and thus can only be called when the BattleStatus is
	// BATTLE_STATE_PENDING).
	//
	// After StartBattle is called, one might want to WatchBattle.
	StartBattle(context.Context, *StartBattleRequest) (*StartBattleResponse, error)
	// CancelBattle forcefully halts a Battle.
	//
	// The Battle's BattleState will be set to BATTLE_STATE_CANCELLED.
	CancelBattle(context.Context, *CancelBattleRequest) (*CancelBattleResponse, error)
	// CallAction invokes an acting Spirit's SpiritAction.
	//
	// This is only valid when a Spirit is currently acting, and
	// the Spirit's BattleTeamSpiritIntelligence is
	// BATTLE_TEAM_SPIRIT_INTELLIGENCE_HUMAN.
	CallAction(context.Context, *CallActionRequest) (*CallActionResponse, error)
	mustEmbedUnimplementedBattleServiceServer()
}

// UnimplementedBattleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBattleServiceServer struct {
}

func (UnimplementedBattleServiceServer) CreateBattle(context.Context, *CreateBattleRequest) (*CreateBattleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBattle not implemented")
}
func (UnimplementedBattleServiceServer) WatchBattle(*WatchBattleRequest, BattleService_WatchBattleServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchBattle not implemented")
}
func (UnimplementedBattleServiceServer) ListBattles(context.Context, *ListBattlesRequest) (*ListBattlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBattles not implemented")
}
func (UnimplementedBattleServiceServer) AddBattleTeam(context.Context, *AddBattleTeamRequest) (*AddBattleTeamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBattleTeam not implemented")
}
func (UnimplementedBattleServiceServer) AddBattleTeamSpirit(context.Context, *AddBattleTeamSpiritRequest) (*AddBattleTeamSpiritResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBattleTeamSpirit not implemented")
}
func (UnimplementedBattleServiceServer) StartBattle(context.Context, *StartBattleRequest) (*StartBattleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBattle not implemented")
}
func (UnimplementedBattleServiceServer) CancelBattle(context.Context, *CancelBattleRequest) (*CancelBattleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBattle not implemented")
}
func (UnimplementedBattleServiceServer) CallAction(context.Context, *CallActionRequest) (*CallActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallAction not implemented")
}
func (UnimplementedBattleServiceServer) mustEmbedUnimplementedBattleServiceServer() {}

// UnsafeBattleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BattleServiceServer will
// result in compilation errors.
type UnsafeBattleServiceServer interface {
	mustEmbedUnimplementedBattleServiceServer()
}

func RegisterBattleServiceServer(s grpc.ServiceRegistrar, srv BattleServiceServer) {
	s.RegisterService(&BattleService_ServiceDesc, srv)
}

func _BattleService_CreateBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBattleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).CreateBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/CreateBattle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).CreateBattle(ctx, req.(*CreateBattleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_WatchBattle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchBattleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BattleServiceServer).WatchBattle(m, &battleServiceWatchBattleServer{stream})
}

type BattleService_WatchBattleServer interface {
	Send(*WatchBattleResponse) error
	grpc.ServerStream
}

type battleServiceWatchBattleServer struct {
	grpc.ServerStream
}

func (x *battleServiceWatchBattleServer) Send(m *WatchBattleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BattleService_ListBattles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBattlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).ListBattles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/ListBattles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).ListBattles(ctx, req.(*ListBattlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_AddBattleTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBattleTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).AddBattleTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/AddBattleTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).AddBattleTeam(ctx, req.(*AddBattleTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_AddBattleTeamSpirit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBattleTeamSpiritRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).AddBattleTeamSpirit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/AddBattleTeamSpirit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).AddBattleTeamSpirit(ctx, req.(*AddBattleTeamSpiritRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_StartBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBattleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).StartBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/StartBattle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).StartBattle(ctx, req.(*StartBattleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_CancelBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelBattleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).CancelBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/CancelBattle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).CancelBattle(ctx, req.(*CancelBattleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_CallAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).CallAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spirits.v1.BattleService/CallAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).CallAction(ctx, req.(*CallActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BattleService_ServiceDesc is the grpc.ServiceDesc for BattleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BattleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "spirits.v1.BattleService",
	HandlerType: (*BattleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBattle",
			Handler:    _BattleService_CreateBattle_Handler,
		},
		{
			MethodName: "ListBattles",
			Handler:    _BattleService_ListBattles_Handler,
		},
		{
			MethodName: "AddBattleTeam",
			Handler:    _BattleService_AddBattleTeam_Handler,
		},
		{
			MethodName: "AddBattleTeamSpirit",
			Handler:    _BattleService_AddBattleTeamSpirit_Handler,
		},
		{
			MethodName: "StartBattle",
			Handler:    _BattleService_StartBattle_Handler,
		},
		{
			MethodName: "CancelBattle",
			Handler:    _BattleService_CancelBattle_Handler,
		},
		{
			MethodName: "CallAction",
			Handler:    _BattleService_CallAction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchBattle",
			Handler:       _BattleService_WatchBattle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "spirits/v1/battle.proto",
}
